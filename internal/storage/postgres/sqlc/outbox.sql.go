// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: outbox.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const claimNextOutboxEvent = `-- name: ClaimNextOutboxEvent :one
WITH next_event AS (
    SELECT id
    FROM click_outbox
    WHERE (
            status = 'pending'
        AND next_attempt_at <= $1
    ) OR (
            status = 'processing'
        AND processing_expires_at <= $1
    )
    ORDER BY created_at ASC
    LIMIT 1
    FOR UPDATE SKIP LOCKED
)
UPDATE click_outbox o
SET
    status = 'processing',
    processing_owner = $2,
    processing_expires_at = $3,
    updated_at = $1
FROM next_event
WHERE o.id = next_event.id
RETURNING o.id, o.event_type, o.slug, o.occurred_at, o.traceparent, o.tracestate, o.baggage, o.status, o.attempts, o.next_attempt_at, o.last_error, o.created_at, o.updated_at, o.processing_owner, o.processing_expires_at, o.sent_at
`

type ClaimNextOutboxEventParams struct {
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	ProcessingOwner     pgtype.Text        `json:"processing_owner"`
	ProcessingExpiresAt pgtype.Timestamptz `json:"processing_expires_at"`
}

func (q *Queries) ClaimNextOutboxEvent(ctx context.Context, arg ClaimNextOutboxEventParams) (ClickOutbox, error) {
	row := q.db.QueryRow(ctx, claimNextOutboxEvent, arg.UpdatedAt, arg.ProcessingOwner, arg.ProcessingExpiresAt)
	var i ClickOutbox
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.Slug,
		&i.OccurredAt,
		&i.Traceparent,
		&i.Tracestate,
		&i.Baggage,
		&i.Status,
		&i.Attempts,
		&i.NextAttemptAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessingOwner,
		&i.ProcessingExpiresAt,
		&i.SentAt,
	)
	return i, err
}

const enqueueClickOutbox = `-- name: EnqueueClickOutbox :one
INSERT INTO click_outbox (
    event_type,
    slug,
    occurred_at,
    traceparent,
    tracestate,
    baggage,
    status,
    attempts,
    next_attempt_at,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, 0, $8, $9, $9
)
RETURNING id, event_type, slug, occurred_at, traceparent, tracestate, baggage, status, attempts, next_attempt_at, last_error, created_at, updated_at, processing_owner, processing_expires_at, sent_at
`

type EnqueueClickOutboxParams struct {
	EventType     string             `json:"event_type"`
	Slug          string             `json:"slug"`
	OccurredAt    pgtype.Timestamptz `json:"occurred_at"`
	Traceparent   pgtype.Text        `json:"traceparent"`
	Tracestate    pgtype.Text        `json:"tracestate"`
	Baggage       pgtype.Text        `json:"baggage"`
	Status        string             `json:"status"`
	NextAttemptAt pgtype.Timestamptz `json:"next_attempt_at"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) EnqueueClickOutbox(ctx context.Context, arg EnqueueClickOutboxParams) (ClickOutbox, error) {
	row := q.db.QueryRow(ctx, enqueueClickOutbox,
		arg.EventType,
		arg.Slug,
		arg.OccurredAt,
		arg.Traceparent,
		arg.Tracestate,
		arg.Baggage,
		arg.Status,
		arg.NextAttemptAt,
		arg.CreatedAt,
	)
	var i ClickOutbox
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.Slug,
		&i.OccurredAt,
		&i.Traceparent,
		&i.Tracestate,
		&i.Baggage,
		&i.Status,
		&i.Attempts,
		&i.NextAttemptAt,
		&i.LastError,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProcessingOwner,
		&i.ProcessingExpiresAt,
		&i.SentAt,
	)
	return i, err
}

const markOutboxRetry = `-- name: MarkOutboxRetry :execrows
UPDATE click_outbox
SET
    status = 'pending',
    last_error = $3,
    next_attempt_at = $4,
    updated_at = $5,
    attempts = attempts + 1,
    processing_owner = NULL,
    processing_expires_at = NULL
WHERE id = $1
  AND status = 'processing'
  AND processing_owner = $2
`

type MarkOutboxRetryParams struct {
	ID              pgtype.UUID        `json:"id"`
	ProcessingOwner pgtype.Text        `json:"processing_owner"`
	LastError       pgtype.Text        `json:"last_error"`
	NextAttemptAt   pgtype.Timestamptz `json:"next_attempt_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) MarkOutboxRetry(ctx context.Context, arg MarkOutboxRetryParams) (int64, error) {
	result, err := q.db.Exec(ctx, markOutboxRetry,
		arg.ID,
		arg.ProcessingOwner,
		arg.LastError,
		arg.NextAttemptAt,
		arg.UpdatedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const markOutboxSent = `-- name: MarkOutboxSent :execrows
UPDATE click_outbox
SET
    status = 'sent',
    sent_at = $3,
    updated_at = $3,
    last_error = '',
    processing_owner = NULL,
    processing_expires_at = NULL
WHERE id = $1
  AND status = 'processing'
  AND processing_owner = $2
`

type MarkOutboxSentParams struct {
	ID              pgtype.UUID        `json:"id"`
	ProcessingOwner pgtype.Text        `json:"processing_owner"`
	SentAt          pgtype.Timestamptz `json:"sent_at"`
}

func (q *Queries) MarkOutboxSent(ctx context.Context, arg MarkOutboxSentParams) (int64, error) {
	result, err := q.db.Exec(ctx, markOutboxSent, arg.ID, arg.ProcessingOwner, arg.SentAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
