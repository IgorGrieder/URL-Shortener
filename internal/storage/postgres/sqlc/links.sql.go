// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: links.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createLink = `-- name: CreateLink :one
INSERT INTO links (
    slug,
    url,
    notes,
    api_key,
    created_at,
    expires_at,
    clicks
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING slug, url, notes, api_key, created_at, expires_at, clicks
`

type CreateLinkParams struct {
	Slug      string             `json:"slug"`
	Url       string             `json:"url"`
	Notes     pgtype.Text        `json:"notes"`
	ApiKey    pgtype.Text        `json:"api_key"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
	Clicks    int64              `json:"clicks"`
}

func (q *Queries) CreateLink(ctx context.Context, arg CreateLinkParams) (Link, error) {
	row := q.db.QueryRow(ctx, createLink,
		arg.Slug,
		arg.Url,
		arg.Notes,
		arg.ApiKey,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.Clicks,
	)
	var i Link
	err := row.Scan(
		&i.Slug,
		&i.Url,
		&i.Notes,
		&i.ApiKey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Clicks,
	)
	return i, err
}

const deleteLinkBySlug = `-- name: DeleteLinkBySlug :execrows
DELETE FROM links WHERE slug = $1
`

func (q *Queries) DeleteLinkBySlug(ctx context.Context, slug string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteLinkBySlug, slug)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getActiveLinkBySlug = `-- name: GetActiveLinkBySlug :one
SELECT slug, url, notes, api_key, created_at, expires_at, clicks FROM links
WHERE slug = $1
  AND (expires_at IS NULL OR expires_at >= $2)
`

type GetActiveLinkBySlugParams struct {
	Slug      string             `json:"slug"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GetActiveLinkBySlug(ctx context.Context, arg GetActiveLinkBySlugParams) (Link, error) {
	row := q.db.QueryRow(ctx, getActiveLinkBySlug, arg.Slug, arg.ExpiresAt)
	var i Link
	err := row.Scan(
		&i.Slug,
		&i.Url,
		&i.Notes,
		&i.ApiKey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Clicks,
	)
	return i, err
}

const getActiveLinkBySlugAndIncClick = `-- name: GetActiveLinkBySlugAndIncClick :one
UPDATE links
SET clicks = clicks + 1
WHERE slug = $1
  AND (expires_at IS NULL OR expires_at >= $2)
RETURNING slug, url, notes, api_key, created_at, expires_at, clicks
`

type GetActiveLinkBySlugAndIncClickParams struct {
	Slug      string             `json:"slug"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GetActiveLinkBySlugAndIncClick(ctx context.Context, arg GetActiveLinkBySlugAndIncClickParams) (Link, error) {
	row := q.db.QueryRow(ctx, getActiveLinkBySlugAndIncClick, arg.Slug, arg.ExpiresAt)
	var i Link
	err := row.Scan(
		&i.Slug,
		&i.Url,
		&i.Notes,
		&i.ApiKey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Clicks,
	)
	return i, err
}

const getLinkBySlug = `-- name: GetLinkBySlug :one
SELECT slug, url, notes, api_key, created_at, expires_at, clicks FROM links WHERE slug = $1
`

func (q *Queries) GetLinkBySlug(ctx context.Context, slug string) (Link, error) {
	row := q.db.QueryRow(ctx, getLinkBySlug, slug)
	var i Link
	err := row.Scan(
		&i.Slug,
		&i.Url,
		&i.Notes,
		&i.ApiKey,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.Clicks,
	)
	return i, err
}
